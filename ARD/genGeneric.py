
HEADER = '\033[95m'
OKBLUE = '\033[94m'
OKGREEN = '\033[92m'
WARNING = '\033[93m'
FAIL = '\033[91m'
ENDC = '\033[0m'
BOLD = "\033[1m"

def autogenWarnStart(sectionName, filePath, commentChar="%"):
	"""Generates a warning that that indicates to readers that the file can
	be overwritten by the ARD scripts.

	:param sectionName: Indicates what section of the script this warning is being generated for
	:type  sectionName: string
	:param filePath: File path of the script that this warning is being generated for
	:type  filePath: string
	:param commentChar: Character that will be used for line comments
	:type  commentChar: string

	:return: Returns the warning
	:rtype: string
	"""
	out = commentChar + " WARNING START OF SECTION AUTOGENERATED BY PYTHON SCRIPT\n"
	out += commentChar + " THIS SECTION MAY BE AUTOMATICALLY CHANGED AT ANY TIME\n"
	out += commentChar + " Autogenerated section name: " + sectionName + "\n"
	out += commentChar + " File path of script: ARD/" + filePath.split("/ARD/")[-1] + "\n"
	return out

def autogenWarnEnd(sectionName, filePath, commentChar="%"):
	"""Generates a warning that that indicates to readers that the file can
	be overwritten by the ARD scripts.

	:param sectionName: Indicates what section of the script this warning is being generated for
	:type  sectionName: string
	:param filePath: File path of the script that this warning is being generated for
	:type  filePath: string
	:param commentChar: Character that will be used for line comments
	:type  commentChar: string

	:return: Returns the warning
	:rtype: string
	"""
	out = commentChar + " WARNING END OF SECTION AUTOGENERATED BY PYTHON SCRIPT\n"
	out += commentChar + " THIS SECTION MAY BE AUTOMATICALLY CHANGED AT ANY TIME\n"
	out += commentChar + " Autogenerated section name: " + sectionName + "\n"
	out += commentChar + " File path of script: ARD/" + filePath.split("/ARD/")[-1] + "\n"
	return out

def usage(fileName):
	pass

def makeCName(value, cType, snakeOrCamel="camel"):
	"""Conveters a string to a C/C++ variable with the specified formatting.
	Does NOT verify that the resulting name is actually valid C/C++

	:param value: The string that should be converted
	:type  value: string
	
	:param cType: Indicates if the string is being converted to a variable or a #define \
	(values are "variable" or "#define")
	:type  cType: string

	:param snakeOrCamel: Indicates if camelCase or snake_case should be used \
	(values are "camel" or "snake")
	:type  snakeOrCamel: string

	:return: The resulting C/C++ name
	:rtype: string
	"""
	outName = ""
	if (cType == "variable"):
		if snakeOrCamel == "snake":
			value = value.lower()
			outName = value.replace(' ', '_')
		elif snakeOrCamel == "camel":
			value = value.lower()
			outName = value.split(' ')[0]
			for word in value.split(' ')[1:]:
				outName += word[0].upper() + word[1:]
		elif snakeOrCamel == "hungarian":
			raise ValueError("Hungarian notation? WTF do you think you are doing?")
		else:
			raise ValueError(f"snakeOrCamel parameter cannot be \"{snakeOrCamel}\".")
	elif (cType == "#define"):
		outName = value.replace(' ', '_').upper()
	return outName

def error(message):
	"""Prints out a message with red lettering to indicate an error. Then halts
	execution with an error.

	:param message: The error message to be printed
	:type  message: string

	:return: Returns nothing
	"""
	print(FAIL + "Error: " + ENDC + message)
	print("Halting execution")
	exit(-1)

def warning(message):
	"""Prints out a message with yello lettering to indicate a warning.

	:param message: The warning message to be printed
	:type  message: string

	:return: Returns nothing
	"""
	print(WARNING + "Warning: " + ENDC + message)